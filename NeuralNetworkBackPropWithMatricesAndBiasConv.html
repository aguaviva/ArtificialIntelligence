<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Neural network back prop, with matrix fomulation</title>
<style type="text/css">
<!--
body { background-color:#ededed; font:norm2al 12px/18px Arial, Helvetica, sans-serif; }
h1 { display:block; width:800px; margin:20px auto; paddVing-bottom:20px; font:norm2al 24px/30px Georgia, "Times New Roman", Times, serif; color:#333; text-shadow: 1px 2px 3px #ccc; border-bottom:1px solid #cbcbcb; }
#container { width:800px; margin:0 auto; }
#myCanvas { background:#fff; border:1px solid #cbcbcb; }
#nav { display:block; width:100%; text-align:center; }
#nav li { display:block; font-weight:bold; line-height:21px; text-shadow:1px 1px 1px #fff; width:100px; height:21px; paddVing:5px; margin:0 10px; background:#e0e0e0; border:1px solid #ccc; -moz-border-radius:4px;-webkit-border-radius:4px; border-radius:4px; float:left; }
#nav li a { color:#000; display:block; text-decoration:none; width:100%; height:100%; }
-->
</style>
</head>
<script>

class Graph
{    
    SetElement(element)
    {
        this.context = element.getContext('2d');
    }
    
    Clear()
    {
        this.context.clearRect(0,0,600,300);
    }

    map(x1,x2,x)
    {
        return (x-x1)/(x2-x1);
    }

    interpol(a,b,t)
    {
        return (1-t)*a + (t)*b;
    }

    AxisX(x1,x2, step) 
    { 
        this.x1 = x1;
        this.x2 = x2;
        this.stepX = step;
    }

    AxisY(y1,y2) 
    { 
        this.y1 = y1;
        this.y2 = y2;
    }

    ToViewportX(x)
    {
        var t = this.map(this.x1,this.x2,x)
        return this.interpol(0,800,t);
    }

    ToViewportY(y)
    {
        var t = this.map(this.y1,this.y2,y)
        return this.interpol(0,300,t);
    }

    Line(x1,y1,x2,y2)
    {
        x1 = this.ToViewportX(x1);
        y1 = this.ToViewportY(y1);
        x2 = this.ToViewportX(x2);
        y2 = this.ToViewportY(y2);
        this.context.moveTo(x1,y1);
        this.context.lineTo(x2,y2);    
    }
    
    Print(x,y, str)
    {
        x = this.ToViewportX(x);
        y = this.ToViewportY(y);
        this.context.fillText(str,x,y);
    }
    
    DrawAxis()
    {
        this.context.beginPath();
        this.context.strokeStyle="#000000";
        this.Line(this.x1,0,this.x2,0);
        this.Line(0,this.y1,0,this.y2);
        this.context.closePath();
        this.context.stroke();
        
        this.context.beginPath();
        for(var i=0;i<this.x2;i+=this.stepX)
        {
            this.Line(i,0,i,-.025);
            this.Print(i,-.05, i);        
        }
        this.context.closePath();
        this.context.stroke();
    }
    
    DrawArray(a, color)
    {
        this.context.beginPath();
        this.context.strokeStyle=color;
        for(var x = 0;x<a.length-1;x++)
        {        
            this.Line(x, a[x], x+1,a[x+1]);
        }
        this.context.closePath();
        this.context.stroke();
    }    
}

//---------------------------------------------------------------------

function RandomMat(inp,neurons)
{
    var L = []
    for(var i=0;i<neurons;i++)
    {
        L[i] = [];7
        for(var j=0;j<inp;j++)
        {
            L[i].push(2*Math.random()-1);
        }
    }
    return L;
}
/*
function PrintMat(m)
{
    var str = "";//"[\n";
    for(var j=0;j<m.length;j++)
    {
    
        var round = [];
        
        for(var i=0;i<m[j].length;i++)
        {
            round.push(m[j][i].toFixed(4))
        }
        str += "[" + round.join(",") + "]\n";
        
        //str += "[" + m[j].join(",") + "]\n";
        
    }
    //str += "]";
    return str;
}
*/
function GetDimensions(m)
{
    o = []
    
    for(;;)
    {
        if (Array.isArray(m)==false)
            break;
            
        o.push(m.length);
        m=m[0];
    }
    return o;
}

function GetArrayDimensions(m)
{
    var dim = 0
    

    dim++; if (Array.isArray(m)==false) return dim;
    dim++; if (Array.isArray(m[0])==false) return dim;
    dim++; if (Array.isArray(m[0][0])==false) return dim;
    dim++; if (Array.isArray(m[0][0][0])==false) return dim;
    dim++; if (Array.isArray(m[0][0][0][0])==false) return dim;    
}



function PrintMat2D(m)
{
    var str = "<pre><table>";
    for(var j=0;j<m.length;j++)
    {
        str += "<tr><td>[</td>";
        for(var i=0;i<m[j].length;i++)
        {            
            str += "<td>" + m[j][i].toFixed(10) + "</td>";
            //str += "<td>" + m[j][i] + "</td>";
        }
        str += "<td>]</td></tr>";
    }
    str += "</table></pre>";

    return str;
}

function PrintMat(mm)
{
    var d = GetDimensions(mm);
    var dim = d.length
    
    if (dim==2)
    {
        return PrintMat2D(mm)
    }
    else if (dim==3)
    {
        var str = ""
        for(var k=0; k<d[0];k++)
        {
            str += PrintMat(mm[k])
        }
    }    
    return str;
}

function RectangularMat(dimX, dimY)
{
    var O = [];
    for(var i=0;i<dimY;i++)
    {
        O[i] = Array(dimX).fill(0);
    }
    return O;
}

function MatId(dimX, value)
{
    var v = RectangularMat(dimX, dimX, value);
    
    for(var i=0;i<dimY;i++)
    {
        v[i][i]=value;
    }    
}

function MulMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m2[0].length;i++)
        {
            var tmp=0;
            for(var k=0;k<m1[0].length;k++)
            {                
                var v = (m1[j][k] * m2[k][i]);
                
                tmp += v;
            }
            O[j].push( tmp);
        }
    }
    return O;
}

function CheckMat(m, msg)
{
    var l = m[0].length;
    for(var j=0;j<m.length;j++)
    {
        if (l!=m[j].length)
            alert("caca");
            
        for(var i=0;i<m[j].length;i++)
        {
            if (typeof m[j][i] !="number")
            {
                console.log(msg+"\n "+  m[j][i]);        
                debugger;
            }
        }        
    }
}

function TransposeMat(m)
{
    var O = [];
    for(var j=0;j<m[0].length;j++)
    {
        O[j]=[];
        for(var i=0;i<m.length;i++)
        {
            O[j][i] = m[i][j];
        }
    }
    return O;
}

function AddMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] + m2[j][i];
        }
    }
    return O;
}

function SimpleMulMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] * m2[j][i];
        }
    }
    return O;
}

function MulKMat(k, m)
{
    var O = [];
    for(var j=0;j<m.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m[0].length;i++)
        {
            O[j][i] = m[j][i] * k;
        }
    }
    return O;
}

function SubMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] - m2[j][i];
        }
    }
    return O;
}

function Square(v)
{
    return MulMat(v, TransposeMat(v))
}

function ConvertMat(m, x,y)
{
    var O = [];
    var n = 0;
    
    for(var j=0;j<y;j++)
        O[j]=[];
    
    for(var j=0;j<m.length;j++)
    {        
        for(var i=0;i<m[0].length;i++)
        {    
            O[Math.floor(n/x)][n % x] = m[j][i];
            n++;
        }    
    }
    
    return O;
}

//---------------------------------------------------------------------


function Act(x)
{
    return x;//1.0/(1.0+Math.exp(-x));
}

function DerAct(x)
{
    return 1;//Act(x)*(1-Act(x));
}


/*
function Act(x)
{
    return 1.0/(1.0+Math.exp(-x));
}

function DerAct(x)
{
    return Act(x)*(1-Act(x));
}
*/
/*
function Act(x)
{
    return Math.max(0,x);
}

function DerAct(x)
{
    return (x>0)?1:0;
}


//softplus 
function Act(x)
{
    return Math.log( 1 + Math.exp(x));
}

function DerAct(x)
{
    return 1.0/(1.0 + Math.exp(-x));
}
*/

//---------------------------------------------------------------------

function funcMat(func, m )
{
    var O = [];
    for(var j=0;j<m.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m[0].length;i++)
        {
            O[j][i] = func(m[j][i]);
        }
    }
    return O;
}

//---------------------------------------------------------------------

class InputLayer
{
    constructor()
    {
        this.name ="Input";
    }

    forwardPass(input)
    {
        this.input = input
        return  input        
    }
}

//----------------------------------------------------------------

class QuadraticCostLayer
{
    constructor()
    {
        this.name ="Quadratic cost";
    }

    setValue(v)
    {
        this.value = v;
    }

    forwardPass(input)
    {
        this.input = input;
        
        this.diff = SubMat(input, this.value);
                
        var err = 0;
        for(var j=0;j<this.diff[0].length;j++)
        {    
            for(var i=0;i<this.diff.length;i++)
            {
                err += this.diff[i][j] * this.diff[i][j];
            }
        }    

        return [[err]];        
    }

    getDerivative()
    {
        return MulKMat(2,this.diff);
    }

    backpropInput( prev, next)
    {
    }
}

class CrossEntropyQuadraticCostLayer
{
    constructor()
    {
        this.name ="Cross Entropy cost";        
    }

    setValue(v)
    {
        this.value = v;
    }

    forwardPass(input)
    {
        this.input = input;
        
        var err = 0;
        var n=0
        for(var j=0;j<input.length;j++)
        {    
            for(var i=0;i<input[0].length;i++)
            {
                var _i = this.value[i][j]
                var _o = input[i][j]                 
                
                err -= _i*Math.log(_o) + (1-_i)*Math.log(1-_o);
                n++;
            }
        }    

        return [[err/n]];                
    }

    getDerivative()
    {
        var num = SubMat(this.input, this.value);
        
        var deno = 0;        
        for(var j=0;j<this.input.length;j++)
        {    
            for(var i=0;i<this.input[0].length;i++)
            {
                var _o = this.input[i][j] 
                deno += (1.0-_o)*_o
            }
        }
        
        return MulKMat(1.0/deno,num);
    }

    backpropInput(next)
    {
    }
}

//----------------------------------------------------------------

function ReverseKernel1D(kernel)
{
    return kernel.slice().reverse();
}

function Add1DPaddingMat(input)
{
    var b = input.slice(0);
    b.unshift(Array(input[0].length).fill(0));
    b.push(Array(input[0].length).fill(0));
    return b;
}

function Conv1DInputForward(nonPaddedInput, weights, bias, padding)
{
    var input = Add1DPaddingMat(nonPaddedInput)

    out = []
    for(var y=0;y<input.length-weights.length+ padding;y++)
    {
        var o = bias;
        for(var i=0;i<weights.length;i++)
        {
            o+= input[y+i][0] * weights[i];
        }
        out[y]=[o];
    }
    return out;
}

//----------------------------------------------------------------

class Conv1D
{
    constructor()
    {
        this.weights = [.1,.2,-.3];
        this.bias = .1;
        this.padding = 1;
        this.name ="Conv1D";
    }

    forwardPass(input)
    {
        this.input = input;
        this.net = Conv1DInputForward(input, this.weights, this.bias, this.padding)
        return funcMat(Act, this.net)
    }

    getDerivative()
    {
        var revWeights =  ReverseKernel1D(this.weights);
        return Conv1DInputForward(this.layerDerivative, revWeights, 0, this.padding);
    }

    backpropInput(next)
    {
        var output = next.getDerivative();

        this.layerDerivative  =  SimpleMulMat(funcMat(DerAct, this.net), output);

        var deltas = []
        for(var i=0;i<this.weights.length+1;i++)
        {
            deltas[i]=[]
        }

        var input = Add1DPaddingMat(this.input) 

        for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
        {
            for(var j=0;j<this.weights.length;j++)
            {
                deltas[j][y] = input[y+j][0];
            }
            deltas[this.weights.length].push(1);
        }
        
        this.deltas = MulMat(deltas,this.layerDerivative);
    }

    train(LearningRate)
    {
        var weights = this.weights.slice(0);
        weights.push(this.bias);
        weights = [weights];
        var deltas = SubMat( weights, TransposeMat((MulKMat(LearningRate,this.deltas))));
        
        this.weights = deltas[0].slice(0,3);
        this.bias = deltas[0][3];
    }

    AddWeight(i,val)
    {
        if (i<this.weights.length)
            this.weights[i]+=val
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        for(var i=0;i<4;i++)
        {
            this.AddWeight(i,.0001)
            outA.push(ForwardPropagation(network, TransposeMat(input)))
            this.AddWeight(i,-.0001)
            outB.push(ForwardPropagation(network, TransposeMat(input)))
        }
        var out = MulKMat(1.0/.0001,SubMat(outA, outB));
        return out;
    }
}

//----------------------------------------------------------------

function ReverseKernel2D(kernel)
{
    var m = [];
    for(var j=0;j<kernel.length;j++)
        m[j] = ReverseKernel1D(kernel[kernel.length-1 - j]);
    return m;
}

function Add2DPaddingMat(input, padding)
{
    var b = [];
              
    for(var i=0;i<input.length;i++)
    {
        var l = input[i].slice(0);
        for(var j=0;j<padding;j++)
            l.unshift(0);
        for(var j=0;j<padding;j++)
            l.push(0);
        b[i+padding] = l;
    }
    
    for(var j=0;j<padding;j++)
        b[j] = Array(b[padding].length).fill(0);    
    for(var j=0;j<padding;j++)
        b[input.length+padding+j] = Array(b[padding].length).fill(0);
        
    return b;
}

function Conv2DInputForward(nonPaddedInput, weights, bias, padding)
{
    var input = Add2DPaddingMat(nonPaddedInput, padding)

    out = []

    for(var y=0;y<input.length - weights.length + 1; y++)
    {
        out[y]=[]
        for(var x=0;x<input[0].length - weights.length + 1; x++)
        {        
            var o = bias;
            for(var j=0;j<weights.length;j++)
            {
                for(var i=0;i<weights[0].length;i++)
                {
                    o += input[y+j][x+i] * weights[i][j];
                }
            }
            
            
            out[y].push(o);
        }
    }
    
    return out;
}

//----------------------------------------------------------------

class Conv2D
{
    constructor()
    {
        this.weights = [ [-.1,.3,.2], [.1,.2,-.3], [.3,-.2,.1] ];
        this.bias = .1;
        this.padding = 1;
        this.name ="Conv2D";
    }

    forwardPass(input)
    {
        this.input = input;
        this.net = Conv2DInputForward(input, this.weights, this.bias, this.padding)
        return funcMat(Act, this.net)
    }

    getDerivative()
    {        
        var revKernel = ReverseKernel2D(this.weights)
        return  Conv2DInputForward(this.layerDerivative, revKernel, 0, this.padding)
    }
    
    backpropInput(next)
    {
        var output = next.getDerivative();

        this.layerDerivative = SimpleMulMat(funcMat(DerAct, this.net), output);

        var ld = [];
        for(var x=0;x<this.layerDerivative.length;x++)
        {
            for(var y=0;y<this.layerDerivative.length;y++)
            {
                ld[x+y*this.layerDerivative.length] = [this.layerDerivative[y][x]];
            }
        }
        

        var deltas = []
        for(var i=0;i<this.weights.length*this.weights.length+1;i++)
        {
            deltas[i]=[]
        }

        var input = Add2DPaddingMat(this.input, this.padding)

        for(var x=0;x<input.length-this.weights.length+ this.padding;x++)
        {
            for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
            {
                for(var i=0;i<this.weights.length;i++)
                {
                    for(var j=0;j<this.weights.length;j++)
                    {
                        deltas[i + j * this.weights.length][x + y * this.input.length] = input[y+j][x+i];
                    }
                }
                deltas[this.weights.length*this.weights.length].push(1);
            }
        }
        
        var deltas = MulMat(deltas,ld);
        this.weightDeltas = ConvertMat(deltas.slice(0, deltas.length-1), 3,3);
        this.biasDeltas   = deltas[deltas.length-1][0]
    }
        
    train(LearningRate)
    {
        this.weights = SubMat( this.weights, TransposeMat(MulKMat(LearningRate,this.weightDeltas)));
        this.bias    = this.bias - LearningRate * this.biasDeltas;
    }        
        
    AddWeight(i,val)
    {
        if (i<this.weights.length*this.weights.length)
            this.weights[i%3][Math.floor(i/3)]+=val
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        for(var i=0;i<3*3+1;i++)
        {
            this.AddWeight(i,.000001)
            outA.push(ForwardPropagation(network, (input)))
            this.AddWeight(i,-.000001)
            outB.push(ForwardPropagation(network, (input)))
        }
        var out = MulKMat(1.0/.000001,SubMat(outA, outB));
        
        return out;
    }
}

//----------------------------------------------------------------
/*
class Conv2DFM
{
    constructor()
    {
        this.weights = [ [ [-.1,.3,.2], [.1,.2,-.3], [.3,-.2,.1] ] ];
        this.bias = [.1 ];
        this.padding = 1;
        this.name ="Conv2DFM";
    }

    forwardPass(input)
    {
        this.input = input;
        var out = []
        this.net = []
        for(var w=0;w<this.weights.length;w++)
        {
            var m = RectangularMat(this.weights[0].length, this.weights[0][0].length)
            for(var i=0;i<this.input.length;i++)
            //var i  =0
            {
                var c = Conv2DInputForward(input[i], this.weights[w], this.bias[w], this.padding);
                m = AddMat(m, c);
            }
            this.net[w] = m
            out[w] = funcMat(Act, this.net[w])
        }
        return out;
    }

    getDerivative()
    {        
        var out = []
        for(var k=0;k<this.weights.length;k++)
        {
            var revKernel = ReverseKernel2D(this.weights[k])
            out[k] = Conv2DInputForward(this.layerDerivative[k], revKernel, 0, this.padding)
        }
        return  out;
    }
    
    backpropInput(next)
    {
        var output = next.getDerivative();

        this.layerDerivative = [] 
        this.weightDeltas = [] 
        this.biasDeltas = [] 

        for(var k=0;k<this.weights.length;k++)
        {
            this.layerDerivative[k] = SimpleMulMat(funcMat(DerAct, this.net[k]), output);

            var ld = [];
            for(var x=0;x<this.layerDerivative[k].length;x++)
            {
                for(var y=0;y<this.layerDerivative[k].length;y++)
                {
                    ld[x+y*this.layerDerivative[k].length] = [this.layerDerivative[k][y][x]];
                }
            }

            var deltas = []
            for(var i=0;i<this.weights.length*this.weights.length+1;i++)
            {
                deltas[i]=[]
            }

            var input  = Add2DPaddingMat(this.input[0], this.padding)            

            for(var x=0;x<input.length-this.weights.length+ this.padding;x++)
            {
                for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
                {
                    for(var i=0;i<this.weights.length;i++)
                    {
                        for(var j=0;j<this.weights.length;j++)
                        {
                            deltas[i + j * this.weights.length][x + y * this.input.length] = input[y+j][x+i];
                        }
                    }
                    deltas[this.weights.length*this.weights.length].push(1);
                }
            }
            
            var deltas = MulMat(deltas,ld);
            this.weightDeltas[k] = ConvertMat(deltas.slice(0, deltas.length-1), 3,3);
            this.biasDeltas[k]   = deltas[deltas.length-1][0]
        }
    }
        
    train(LearningRate)
    {
        for(var k=0;k<this.weights.length;k++)
        {
            this.weights[k] = SubMat( this.weights[k], MulKMat(LearningRate,this.weightDeltas[k]));
            this.bias[k]    = this.bias[k] - LearningRate * this.biasDeltas[k];
        }
    }        
        
    AddWeight(i,val)
    {
        if (i<this.weights.length*this.weights.length)
            this.weights[i%3][Math.floor(i/3)]+=val
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        
        //var outA = []
        //var outB = []
        //for(var i=0;i<3*3+1;i++)
        //{
        //    this.AddWeight(i,.000001)
        //    outA.push(ForwardPropagation(network, TransposeMat(input)))
        //    this.AddWeight(i,-.000001)
        //    outB.push(ForwardPropagation(network, TransposeMat(input)))
        //}
        //var out = MulKMat(1.0/.000001,SubMat(outA, outB));
        
        //return out;
        
    }
}
*/

class Conv2DFM
{
    constructor()
    {
        this.fm = [];
        this.name ="Conv2DFM";
    }

    forwardPass(input)
    {
        this.input = input;

        var out = []
        for(var w=0;w<this.fm.length;w++)
        {
            out[w] = this.fm[w].forwardPass(input[0]);
        }
        return out;
    }

    getDerivative()
    {        
        var out = []
        
        for(var w=0;w<this.fm.length;w++)
        {
            out[w] = this.fm[w].getDerivative();
        }
        
        return  out;
    }
    
    backpropInput(next)
    {
        this.weightDeltas = []
        this.biasDeltas = []
        
        for(var w=0;w<this.fm.length;w++)
        {
            this.fm[w].backpropInput(next);
            
            this.weightDeltas[w] = this.fm[w].weightDeltas;
            this.biasDeltas[w]   = this.fm[w].biasDeltas;
        }                
    }
        
    train(LearningRate)
    {
        for(var w=0;w<this.fm.length;w++)
        {
            this.fm[w].train(LearningRate);
        }                
    }        
        
    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        
        for(var w=0;w<this.fm.length;w++)
        {
            for(var i=0;i<3*3+1;i++)
            {
                this.fm[w].AddWeight(i,.000001)
                outA.push(ForwardPropagation(network, TransposeMat(input)))
                this.fm[w].AddWeight(i,-.000001)
                outB.push(ForwardPropagation(network, TransposeMat(input)))
            }
        }        

        var out = MulKMat(1.0/.000001,SubMat(outA, outB));

        return out;
    }
}


//----------------------------------------------------------------
function Add3DPaddingMat(input, padding)
{
    b = [];
    
    for(var i=0;i<padding;i++)
        b[i] = RectangularMat(input.length + 2*padding, input[i].length + 2*padding);
    
    for(var i=0;i<input.length;i++)
    {
        b[i+padding] = Add2DPaddingMat(input[i], padding);
    }
    
    for(var i=0;i<padding;i++)
        b[input.length + padding + i] = RectangularMat(input.length + 2*padding, input[i].length + 2*padding);

    return b;
}

function ReverseKernel3D(kernel)
{
    var m = [];
    for(var j=0;j<kernel.length;j++)
        m[j] = ReverseKernel2D(kernel[kernel.length-1 - j]);
    return m;
}

function Conv3DInputForward(Input, weights, bias, padding)
{
    var out = Conv2DInputForward(Input[0], weights[0], bias, padding);
    for(var n=1;n<Input.length;n++)
    {
        var slice = Conv2DInputForward(Input[n], weights[n], 0, padding);  //only the first one uses the bias
        
        for(var y=0;y<slice.length;y++)
        {            
            for(var x=0;x<slice[0].length;x++)
            {
                out[y][x] += slice[y][x];
            }
        }
        
    }
    
    return out;
}

//----------------------------------------------------------------

class Conv3D
{
    constructor()
    {
        this.weights = [
        [ [-.1,.2,.3], [.1,.2,-.3], [.1,-.2,.3] ],
        [ [-.1,.2,.3], [-.1,.2,-.3], [.1,-.2,.3] ],
        [ [-.1,.2,-.3], [.1,.2,-.3], [.1,-.2,-.3] ],
        ];
        this.bias = .1;
        this.padding = 1;
        this.name ="Conv3D";
    }

    forwardPass(input)
    {
        this.input = input;
        this.net = Conv3DInputForward(input, this.weights, this.bias, this.padding)
        return funcMat(Act, this.net)
    }

    getDerivative()
    {        
        var revKernel = ReverseKernel3D(this.weights)
        return  Conv3DInputForward(this.layerDerivative, revKernel, 0, this.padding)
    }
    
    backpropInput(next)
    {
        var output = next.getDerivative();

        this.layerDerivative = SimpleMulMat(funcMat(DerAct, this.net), output);

        var ld = [];
        for(var x=0;x<this.layerDerivative.length;x++)
        {
            for(var y=0;y<this.layerDerivative.length;y++)
            {
                ld[x+y*this.layerDerivative.length] = [this.layerDerivative[y][x]];
            }
        }
        
        var deltas = []
        for(var i=0;i<this.weights.length*this.weights[0].length*this.weights[0][0].length+1;i++)
        {
            deltas[i]=[]
        }

        var input = Add3DPaddingMat(this.input, this.padding)

        for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
        {
            for(var x=0;x<input.length-this.weights.length+ this.padding;x++)
            {            
                for(var k=0;k<this.weights.length;k++)
                {
                    for(var j=0;j<this.weights[0].length;j++)
                    {                            
                        for(var i=0;i<this.weights[0][0].length;i++)
                        {
                            deltas[i + j * this.weights.length + k * this.weights.length* this.weights[0].length][x + y * this.input.length] = input[k+1][y+j][x+i];
                        }
                    }
                }
                deltas[this.weights.length*this.weights[0].length*this.weights[0][0].length].push(1);
            }
        }
        
        this.deltas = MulMat(deltas,ld);
    }
        
    AddWeight(i,val)
    {
        if (i<this.weights.length*this.weights[0].length*this.weights[0][0].length)
        {
            var x = Math.floor(i/3) % 3;
            var y = i % 3;            
            var z = Math.floor(i/9) % 3;
        
            this.weights[z][y][x]+=val
        }
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        for(var i=0;i<this.weights.length*this.weights[0].length*this.weights[0][0].length+1;i++)
        {
            this.AddWeight(i,.0001)
            outA.push(ForwardPropagation(network, TransposeMat(input)))
            this.AddWeight(i,-.0001)
            outB.push(ForwardPropagation(network, TransposeMat(input)))
        }
        var out = MulKMat(1.0/.0001,SubMat(outA, outB));
        
        return out;
    }
}

//----------------------------------------------------------------

class FullyConnected
{
    constructor(neurons, inp)
    {
        this.name ="Fully";
        this.weights = []
        this.bias = []
        this.bias[0] = []
        
        for(var i=0;i<neurons;i++)
        {
            this.weights[i] = [];

            for(var j=0;j<inp;j++)
                this.weights[i].push(2*Math.random()-1);
            
            
        }
        
        for(var i=0;i<inp;i++)
            this.bias[0][i] = (2*Math.random()-1);            
    }

    forwardPass(input)
    {
        this.input = input;
        this.net = MulMat(input, this.weights )
        this.net = AddMat(this.bias, this.net)
        return funcMat(Act, this.net)        
    }

    getDerivative()
    {
        var t = TransposeMat(this.weights)
        return MulMat(this.layerDerivative, t);
    }

    backpropInput(next)
    {
        var output = next.getDerivative();
        var sigmaDerNet = funcMat(DerAct, this.net);
        this.layerDerivative = SimpleMulMat(sigmaDerNet, output);
        
        // for training
        this.weightDeltas = MulMat(TransposeMat(this.input), this.layerDerivative);
        this.biasDeltas   = this.layerDerivative;
    }

    train(LearningRate)
    {
        this.weights = SubMat( this.weights, MulKMat(LearningRate,this.weightDeltas));
        this.bias    = SubMat( this.bias,    MulKMat(LearningRate,this.biasDeltas));
    }

    numericalDerivarive(network, input)
    {
        var out = []
        for(var j=0;j<this.weights.length;j++)
        {
            var vA = []
            var vB = []
            for(var i=0;i<this.weights[0].length;i++)
            {
                this.weights[j][i] += .0001
                vA.push(ForwardPropagation(network, input)[0])
                this.weights[j][i] -= .0001
                vB.push(ForwardPropagation(network, input)[0])
            }
            var c = MulKMat(1.0/.0001,TransposeMat(SubMat(vA, vB)));

            out.push(c)
        }

        for(var j=0;j<this.bias.length;j++)
        {
            var vA = []
            var vB = []
            for(var i=0;i<this.bias[0].length;i++)
            {
                this.bias[j][i] += .0001
                vA.push(ForwardPropagation(network, input)[0])
                this.bias[j][i] -= .0001
                vB.push(ForwardPropagation(network, input)[0])
            }
            var c = MulKMat(1.0/.0001,TransposeMat(SubMat(vA, vB)));

            out.push(c)
        }

        return out;
    }
}

//----------------------------------------------------------------

class MaxPool1D
{
    constructor()
    {
        this.name ="MaxPool 1D";
    }

    forwardPass(input)
    {
        this.o = Array(input.length/2).fill(0)
        this.index = Array(input.length/2).fill(0)
    
        this.errDer = [];
        for(var i=0;i<input.length/2;i++)
        {
            var a = input[i*2][0];
            var b = input[i*2 +1][0];
            this.o[i] = [Math.max(a,b)];
                        
            var row = Array(input.length).fill(0);
            if (a>b)
            {
                row[2*i] = 1;
            }
            else
            {
                row[2*i+1] = 1;
            }
            this.errDer.push(row);
        }
        
        this.input = input;
        return this.o;
    }

    getDerivative()
    {
        /*
        var out = [];
        for(var i=0;i<this.input.length/2;i++)
        {
            var row = Array(this.input.length).fill(0);
            
            var a = this.input[i*2][0];
            var b = this.input[i*2 +1][0];
            if (a>b)
            {
                row[2*i] = 1;
            }
            else
            {
                row[2*i+1] = 1;
            }
            
            out.push(row);
        }    
        */
        out = this.errDer;
        
        return MulMat(TransposeMat(out), this.layerDerivative);        
    }

    backpropInput(next)
    {
        this.layerDerivative  =  next.getDerivative();

        this.deltas = [];
    }

    train(LearningRate) {};
    
    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MidPool1D
{
    constructor()
    {
        this.name ="MidPool 1D";
    }

    forwardPass(input)
    {
        this.input = input;
        var o = Array(input.length/2).fill(0)
    
        for(var i=0;i<input.length/2;i++)
        {
            var a = input[i*2][0];
            var b = input[i*2 +1][0];
            o[i] = [(a+b)*0.5];     // average
        }
        
        return o;
    }

    getDerivative()
    {
        var out = [];

        var out = [];
        for(var j=0;j<this.layerDerivative.length;j++)
        {
            var row = [];
            for(var i=0;i<this.layerDerivative[0].length;i++)
            {
                var v = this.layerDerivative[j][i];
                out.push( [v*.5] );
                out.push( [v*.5] );
            }
        }        

        return out;
    }

    backpropInput(next)
    {
        var output = next.getDerivative();

        this.layerDerivative  =  output;

        this.deltas = [];
    }
    
    train(LearningRate) {};

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MidPool2D
{
    constructor()
    {
        this.name ="MidPool 2D";
    }

    forwardPass(input)
    {
        this.input = input;
        
        var o = []    
        for(var y=0;y<input.length/2;y++)
        {
            var row = [];
            for(var x=0;x<input[0].length/2;x++)
            {
                var a = input[y*2][x*2];
                var b = input[y*2][x*2+1];
                var c = input[y*2+1][x*2];
                var d = input[y*2+1][x*2+1];
                row[x] = (a+b+c+d)*0.25;     // average
            }
            o.push(row)
        }        
        return o;
    }

    getDerivative()
    {
        var out = [];

        for(var y=0;y<this.layerDerivative.length;y++)
        {
            var row1 = [];
            var row2 = [];

            for(var x=0;x<this.layerDerivative[0].length;x++)
            {
                var v = this.layerDerivative[y][x];
                
                row1.push(v*.25); row1.push(v*.25);
                row2.push(v*.25); row2.push(v*.25);
            }
            out.push(row1);
            out.push(row2);
        }    
                
        return out;        
    }

    backpropInput(next)
    {
        this.layerDerivative  =  next.getDerivative();

        this.deltas = [];
    }

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MaxPool2D
{
    constructor()
    {
        this.name ="MaxPool 2D";
    }

    forwardPass(input)
    {        
        this.input = input;
        
        var o = []    
        this.errDer = [];
        for(var y=0;y<input.length/2;y++)
        {
            var row = [];
            var rowErrDer1 = [];
            var rowErrDer2 = [];
            for(var x=0;x<input[0].length/2;x++)
            {
                var a = input[y*2  ][x*2];   var b = input[y*2  ][x*2+1];
                var c = input[y*2+1][x*2];   var d = input[y*2+1][x*2+1];
                
                var res = Math.max(a,Math.max(b,Math.max(c,d)));
                
                row.push(res);
                
                var m = 0;
                if (a==res) m++;
                if (b==res) m++;
                if (c==res) m++;
                if (d==res) m++;
                
                m = 1.0/m;
                                
                rowErrDer1.push( (a==res)?m:0 ); rowErrDer1.push( (b==res)?m:0 );
                rowErrDer2.push( (c==res)?m:0 ); rowErrDer2.push( (d==res)?m:0 );
            }
            
            o.push(row);
            
            this.errDer(rowErrDer1);
            this.errDer(rowErrDer2);
        }        
        
        return o;
    }

    getDerivative()
    {               
        return this.errDer;        
    }

    backpropInput(next)
    {
        this.layerDerivative  =  next.getDerivative();

        this.deltas = [];
    }

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------



class Flatten
{
    constructor(dimIni)
    {    
        this.dimIni = dimIni;
        this.name ="Flatten";
    }

    forwardPass(input)
    {        
        if (Array.isArray(input))
        {
            if (Array.isArray(input[0]))
            {
                if (Array.isArray(input[0][0]))
                {
                    this.input = input;
                }
                else
                {
                    this.input = [input];
                }
            }
            else
            {
                this.input = [[input]];
            }
        }
        else
        {
            this.input = [[[input]]];
        }
        

        var row = []

        this.depth  = this.input.length;
        this.height = this.input[0].length;
        this.width  = this.input[0][0].length;


        for(var z=0;z<this.depth;z++)
        {
            for(var x=0;x<this.width;x++)
            {
                for(var y=0;y<this.height;y++)
                {
                    row.push(this.input[z][y][x]);
                }
            }        
        }        
        
        this.o = [row];
        
        
        return this.o;
    }

    getDerivative()
    {                       
        var out = [];
        
        var input = this.layerDerivative;

        for(var z=0;z<this.depth;z++)
        {
            
            for(var x=0;x<this.width;x++)
            {
                var row = [];
                for(var y=0;y<this.height;y++)    
                {
                    row.push(input[0][z*this.height*this.width + y*this.width+ x]);
                }
                out.push(row);
            }        
        }    
        
        return out;
    }

    backpropInput(next)
    {
        this.layerDerivative  =  next.getDerivative();

        this.deltas = [];
    }

    train(LearningRate) {};
    
    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class CombineFeatureMaps
{
    constructor(featureMap)
    {
        this.name ="CombineFeatureMaps";

        this.featureMap = featureMap;
    }

    forwardPass(input)
    {
        this.input = input;
        
        var o = [];
        for(var fmo=0;fmo<this.featureMap.length;fmo++)
        {
            var m = RectangularMat(input[0].length, input[0][0].length);
            for(var fmi=0;fmi<input.length;fmi++)
            {
                m = AddMat(m, this.featureMap[fmo].forwardPass(input[fmi]));            
            }
            o[fmo] = m;
        }
        return o;
    }

    getDerivative()
    {
        var m = RectangularMat(input[0].length, input[0][0].length);
        for(var fmi=0;fmi<input.length;fmi++)
        {
            m = AddMat(m, this.featureMap[fmo].getDerivative());            
        }        
        
        return m;
    }
    
    backpropInput(next)
    {
        this.layerDerivative  =  next.getDerivative();
    }
     

    train(LearningRate)
    {
        for(var i=0;i<this.featureMap.length;i++)
        {
            this.featureMap[i].train(LearningRate);
        }
    }
   
    numericalDerivarive(network, input)
    {
        var out = []
         for(var i=0;i<this.featureMap.length;i++)
        {
            outA.push(this.featureMap[i].numericalDerivarive(network, input[i]));
        }        
        return out;
    }
}

//----------------------------------------------------------------

class PackLayers
{
    constructor()
    {    
        this.name ="PackLayers";
        this.layers = []
    }

    setLayers(layers) 
    { 
        this.layers = layers;
    };

    forwardPass(input)
    {        
        this.input = input;
        
        var res = input
        for(var i=0;i<this.layers.length;i++)
        {
            res = this.layers[i].forwardPass(res);
        }                
        
        return res;    
    }
    
    getDerivative()
    {                       
        return this.layers[0].getDerivative();
    }
    
    backpropInput(next)
    {
        for(var i=this.layers.length-1;i>=0;i--)
        {
            var curr = i
            var prev = (curr == 0)                    ? prev: this.layers[curr - 1];
            var next = (curr == this.layers.length-1) ? next: this.layers[curr + 1];
            this.layers[curr].backpropInput(prev, next);
        }
        
        this.layerDerivative  =  this.layers[this.layers.length-1].layerDerivative;
        
        this.deltas = [];
    }        
    
    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

function EvalNetwork(network, input)
{
    var res = input
    for(var i=0;i<network.length-1;i++)
    {
        res = network[i].forwardPass(res);
    }
    return res;
}


function ForwardPropagation(network, input)
{
    var res = input
    for(var i=0;i<network.length;i++)
    {
        res = network[i].forwardPass(res);
    }
    
    return res;
}

function BackwardPropagation(network)
{
    for(var i=network.length-2;i>0;i--)
    {
      network[i].backpropInput(network[i + 1]);
    }
}

function ApplyDeltas(network, LearningRate)
{
    for(var i=1;i<network.length-1;i++)
    {
        network[i].train(LearningRate);
    }
}

function CalcError(network, input, output)
{
    var totalErr = 0;
    for(var i=0;i<input.length;i++)
    {
        var err = SubMat(ForwardPropagation(network, input[i]), output[i]);
        totalErr += MulMat(err, TransposeMat(err))[0][0];
    }
    return totalErr;
}

function SimpleTrain(network, input, output, LearningRate, epocsCount, iters)
{
    var t0 = performance.now();
    
    for(var l=0;l<iters;l++)
    {
        for(var epocs=0;epocs<epocsCount;epocs++)
        {
            for(var i=0;i<input.length;i++)
            {
                network[network.length-1].setValue(output[i]);
                
                ForwardPropagation(network, input[i])
                BackwardPropagation(network);
                
                ApplyDeltas(network, LearningRate);
            }
        }
    
        Print(CalcError(network, input, output).toFixed(4) + " : ");
        Print("  cost"+network[network.length-1].name+network[network.length-1].o + " : ");
        
        /*
        for(var i=0;i<input.length;i++)
            Print(PrintMat(ForwardPropagation(network, input[i])));
        */
        Print("<br>");
    }
    
    var t1 = performance.now();
    Print("time: " + (t1 - t0) + " milliseconds.<br>");
}


function PrepareData(data)
{
    var out = []
    for(var d=0;d<data.length;d++)
    {
        var dd = [];
        for(var i=0;i<data[d].length;i++)
            dd.push([data[d][i]]);
        
        out.push(dd);
    }
    return out;
}

//--------------------------------------------------------------------


//--------------------------------------------------------------------

function Train_XOR()
{
    Print("Learning a xor:<br><br>");
    var input = PrepareData([[0,0],[1,0],[0,1],[1,1]]);
    var output = PrepareData([[0],[1],[1],[0]]);
    
    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(4,2));
    network.push(new FullyConnected(1,4));
    network.push(new QuadraticCostLayer());


    //network[network.length-1].setValue(output[1]);
    //ForwardPropagation(network, input[1])
    //DumpWeights(network)

    SimpleTrain(network, input, output, .1, 1000,10);        
    
    Print("<pre>---------------------------------</pre>");
}

function generate_SIN(size, freq, offset)
{
    var v = Array(size).fill(0)
    for(var t=0;t<size;t++)
    {
        v[t] = Math.sin((2*3.1415)*freq*((t+offset)/(size)));
    }
    return v;
}

function generate_SIN_training(size)
{
    var input = [];
    var output = [];
    
    for(var offset=0;offset<5;offset++)
    {
        for(var f=0;f<size;f++)
        {
            var v = generate_SIN(size, f+1, offset);
            input.push(v);
            output.push((f==0)?[1]:[0]);
        }
        
        {
            var v = Array(size).fill(0)
            for(var i=0;i<size;i++)
            {
                v[i]=i;
            }
            input.push(v);
            output.push([0]);
        }        

        {
            var v = Array(size).fill(0)
            for(var i=0;i<size;i++)
            {
                v[i]=2*Math.random()-1;
            }
            input.push(v);
            output.push([0]);
        }        

        
    }    
    
    return [PrepareData(input), PrepareData(output)];
}

//----------------------------------------------------------------

function Print(str)
{
    document.getElementById("text").innerHTML += str;
}

function DumpLayer(n, output)
{
    

    if (n.weights!=undefined)
    {
        out +="<td>"+PrintMat(n.weights)+"</td>";            
    }
    
    if (n.bias!=undefined)
        if (Array.isArray(n.bias))
            out +="<td>"+PrintMat(n.bias)+"</td>";            
        else
            out += "<td>" + n.bias.toFixed(4) + "</td>";
            
    out += "<td>" + PrintMat(output) + "</td>";        
    return out
}

function DumpWeights(network, input)
{    
    var res = input
    
    for(var i=0;i<network.length;i++)
    {
        var n = network[i];
        
        res = n.forwardPass(res);
    
        out = ""
        out +="<table>";
        
        out +="<tr>";
        out +="<td>name</td>";
        if (n.weights!=undefined)
            out +="<td>weights</td>";
        if (n.bias!=undefined)
            out +="<td>bias</td>";
        out +="<td>output</td>";
        
        out +="</tr>";
                
        if (n.featureMap == undefined)
        {
            out +="<tr>";
            out +="<td>"+n.name+"</td>";
            DumpLayer(n, res)
            out +="<tr>";
        }
        else
        {
            for (var j=0;j<n.featureMap.length;j++)
            {
                out += "<tr>" + "<td>"+n.name+"["+j+"]</td>"; DumpLayer(n.featureMap[j], undefined) + "</tr>";
            }
        }
            
        out +="</table>";
        
        Print(out)
    }
}

function TestNetwork(network, input, output, inputLayer)
{
    network[network.length-1].setValue(output);

    ForwardPropagation(network, input)
    for(var i=1;i<network.length-1;i++)
    {
        Print("<pre>"+i+") Forward pass: "+network[i].name+"</pre>");
        
        if (network[i].name!="CombineFeatureMaps")        
            Print("<pre>"+PrintMat(TransposeMat(network[i+1].input))+"</pre>");
    }

    Print("<pre>---------------------------------</pre>");

    var str = "<table><tr><td>analytical</td><td>numerical</td></tr><tr><td>";

    BackwardPropagation(network);

    for(var i=1;i<network.length-1;i++)
    {
        str += "<pre>"+i+" '" + network[i].name + "'</pre>";
        str += "<pre>weights: "+PrintMat(network[i].weightDeltas)+"</pre>";
        str += "<pre>bias: "+network[i].biasDeltas+"</pre>";
    }

    str += "</td><td>";

    //numerical derivative
    for(var i=1;i<network.length-1;i++)
    {
        str += "<pre>"+i+" '" + network[i].name + "'</pre>";
        var c = network[i].numericalDerivarive(network, input);
        str += "<pre>"+PrintMat(c)+"</pre>";
    }

    str += "</tr></table>";

    Print(str);
}


function Train_SIN_fully(trainingSet)
{    
    Print("Learning a sin fully:<br><br>");

    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(5,trainingSet.length));
    network.push(new FullyConnected(1,5));
    network.push(new QuadraticCostLayer());
    
    SimpleTrain(network, trainingSet[0], trainingSet[1], .1, 200, 10);        
    
    Print("<pre>---------------------------------</pre>");
    
    return network;
}

function Train_SIN_conv(trainingSet)
{    
    Print("Learning a sin conv:<br><br>");
    
    var network =[]
    network.push(new InputLayer());
    network.push(new Conv1D());    
    network.push(new MidPool1D());
    //network.push(new MaxPool1D());
    network.push(new Conv1D());    
    network.push(new MidPool1D());
    //network.push(new MaxPool1D());
    
    network.push(new FullyConnected(1,4));
    network.push(new QuadraticCostLayer());

    SimpleTrain(network, trainingSet[0], trainingSet[1], .1, 200, 10);        
    
    Print("<pre>---------------------------------</pre>");
    
    return network;
}

function Test_FullyConnected_1()
{
    var input = [[3,2,3,4]];
    var output = [[1,0,0,0]];

    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(4,4));
    network.push(new QuadraticCostLayer());

    TestNetwork(network, input, output)
}

function Test_FullyConnected_2()
{
    var input = [[1,2,3,4]];
    output = [[1]]

    var network =[]

    network.push(new InputLayer());
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(4,2));
    network.push(new FullyConnected(2,1));
    network.push(new QuadraticCostLayer());


    TestNetwork(network, input, output)
}

function Test_Conv1DPool()
{
    var input = [[1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    //network.push(new MidPool1D());
    network.push(new MaxPool1D());
    network.push(new QuadraticCostLayer());

    output = [[1]]

    TestNetwork(network, input, output)
}

function Test_Conv1DDebug()
{
    var input = [[1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new Conv1D());    
    network.push(new QuadraticCostLayer());

    output = [[1,2]]

    TestNetwork(network, input, output)
}

function Test_Conv1DDebug4()
{
    var input = [[1,2,3,4]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new Conv1D());
    network.push(new Conv1D());
    network.push(new Conv1D());
    network.push(new QuadraticCostLayer());

    output = [[1,20,3,20]]

    TestNetwork(network, input, output)
}

function Test_pack()
{
    var p = new PackLayers()
    p.setLayers( [ new Conv1D(), new Conv1D() ] )
    
    var input = [[1,2,3,4]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(p);
    network.push(new Conv1D());
    network.push(new QuadraticCostLayer());

    output = [[1,20,3,20]]

    TestNetwork(network, input, output)
}


function Test_Conv1DAndFullyConnected()
{
    var input = [[5,2,1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new FullyConnected(2,2));
    network.push(new FullyConnected(1,2));
    network.push(new QuadraticCostLayer());

    output = [[1]];

    TestNetwork(network, input, output)
}

function Test_Conv1DAndMaxPoolAndFullyConnected2()
{
    var input = [[1,2,3,4,5,6,7,8]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new Conv1D());
    network.push(new FullyConnected(2,2));
    network.push(new QuadraticCostLayer());

    output = [[1,2]];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug1()
{
    var input = [
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
    ];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new QuadraticCostLayer());

    var output = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
    ];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug2()
{
    var input = [
        [.01,.02,.03,.04],
        [.05,.06,.07,.08],
        [.01,.02,.03,.04],
        [.03,.02,.03,.01],
    ];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new MidPool2D());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new QuadraticCostLayer());

    var output = [
        [0,0],
        [0,0],
    ];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug3()
{
    var input = [
        [.01,.02,.03,.04],
        [.05,.06,.07,.08],
        [.01,.02,.03,.04],
        [.03,.02,.03,.01],
    ];

    var network = []

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Flatten());
    network.push(new FullyConnected(1, 16));

    network.push(new QuadraticCostLayer());

    var output = [ [
    1
    ]];

    TestNetwork(network, input, output)
}

function Train_3dConv()
{
    var input = [
            [.01,.02,.03],
            [.05,.06,.07],
            [.01,.02,.03],
    ];

    var il = new InputLayer();

    var p1 = new PackLayers();
    p1.setLayers( [ il, new Conv2D() ])
    var p2 = new PackLayers();
    p1.setLayers( [ il, new Conv2D() ])
    var p3 = new PackLayers();
    p1.setLayers( [ il, new Conv2D() ])

    var cfm = new CombineFeatureMaps([p1,p2,p3]);

    var network = []
    network.push(cfm);
    network.push(new Conv3D());
    network.push(new Flatten());
    network.push(new FullyConnected(1, 3*3));
    network.push(new QuadraticCostLayer());

    var output = [ [
    1
    ]];

    TestNetwork(network, input, output, il)
}

function Test_LearnSin()
{
    var trainingSet = generate_SIN_training(16);

    var sin_fully = Train_SIN_fully(trainingSet);
    var sin_conv  = Train_SIN_conv(trainingSet);
    
    var g = new Graph();
    g.SetElement(myCanvas);
    g.Clear();
    g.AxisX(0,160,10); 
    g.AxisY(1,-.1);
    g.DrawAxis();

    output_full = []
    output_conv = []
    for(var n = 0;n<160;n++)
    {
        var data = generate_SIN(16,(n+1)/10.0,Math.random()*0);    
        data = TransposeMat([data]);
                
        output_full.push(EvalNetwork(sin_fully, data))
        output_conv.push(EvalNetwork(sin_conv, data));
    }    
    g.DrawArray(output_full,"#ff0000");
    g.DrawArray(output_conv,"#00ff00");
}

function Train_XOR_TF()
{
    Print("Learning a xor TF:<br><br>");
    var input = PrepareData([[0,0],[0,1],[1,0],[1,1]]);
    var output = PrepareData([[0],[1],[1],[0]]);

    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(2,2));
    network.push(new FullyConnected(1,2));
    network.push(new QuadraticCostLayer());
    //network.push(new CrossEntropyQuadraticCostLayer());
    
    network[1].weights = TransposeMat([[-0.60878801, -0.94027829], [-0.27013826, -0.48769999]])        
    network[1].bias = TransposeMat([[0,0] ])        
    network[2].weights = TransposeMat([[ 0.74871302], [0.86548233]])
    network[2].bias = TransposeMat([[0]])

    for(var i=0;i<10;i++)
    {
        network[network.length-1].setValue(output[1]);
        ForwardPropagation(network, input[1])
        DumpWeights(network, input[1])
        BackwardPropagation(network);
        LearningRate = 0.01
        ApplyDeltas(network, LearningRate);
    }    
    
    TestNetwork(network, input, output)

    
    Print("<pre>---------------------------------</pre>");
}

// Good!
function Train_Conv2D_TF()
{
    var input = [
        [0.0,0.0,0.0],
        [0.0,0.0,0.0],
        [0.0,0.0,1.0],
    ];

    var output = [
        [.0,.0,.0],
        [.0,.0,.0],
        [.0,.0,.0],
    ];

    var network = []

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new QuadraticCostLayer());

    network[1].weights = TransposeMat([[0.27138534, 0.38108054, 0.09319559], [0.35629138, -0.31773868, 0.04325816], [0.4367952, -0.42410958, -0.39009494]])
    network[1].bias = 0.0
    network[2].weights = TransposeMat([[0.18893692, 0.17201874, -0.054582655], [-0.072298825, -0.29197967, 0.28130314], [0.3995901, -0.25968382, 0.3133864]])
    network[2].bias = 0.0

    for(var i=0;i<3;i++)
    {
        network[network.length-1].setValue(output);
        
        ForwardPropagation(network, input)
        DumpWeights(network, input)
        
        BackwardPropagation(network);
        ApplyDeltas(network, 0.01);
    }
    
    TestNetwork(network, input, output)
}

// 
function Train_Conv2D_TF_flatten()
{
    var input = [
        [0.0,0.0,0.0],
        [0.0,0.0,0.0],
        [0.0,0.0,1.0],
    ];

    var output = 
    [
        [0, 0, 0, 0, 0, 0, 0, 0, 0] 
    ];


    var network = []

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new Flatten());
    network.push(new FullyConnected(9, 9));
    network.push(new QuadraticCostLayer());

    network[1].weights = TransposeMat([[ 0.33237779, 0.23139948, 0.46672642], [ 0.21067905, 0.11414081,-0.06684983], [ 0.43636596,-0.08854762,-0.38914883]])        
    network[1].bias = 0.0
    network[2].weights = TransposeMat([[0.33330685, 0.31929517, 0.34561253], [0.43682992, 0.23200583, 0.34399903], [-0.22470084, 0.25076467, -0.33110029]])        
    network[2].bias = 0.0    
    network[4].weights = TransposeMat(
    [[-0.02658027, -0.26800793, -0.28104788, -0.2675036, 0.2387929, 0.18912, -0.07358658, -0.28363615, -0.22685868],
     [ 0.03684437, -0.4047982,  -0.30146456, -0.32418275,  0.07153296, -0.36852154, -0.3568197,  -0.05572432, 0.10487837],
     [-0.3503779,   0.5062556,   0.15244246, -0.40669078,  0.05453527, -0.31552494, -0.16776782,  0.330204, -0.23390612],
     [-0.17094743, -0.40869665,  0.51525974,  0.2501316,  -0.3876908,   0.28606236,  0.15706134,  0.39526904, 0.5108069 ],
     [-0.11189431, -0.26786697,  0.45179045, -0.09239852,  0.5086441,  -0.30125904, -0.0082702,   0.01796913, -0.15071025],
     [ 0.3898331,  -0.05860412,  0.46107602, -0.10246646,  0.0860498,   0.24718064, -0.1354866,  -0.16091818, 0.38205552],
     [ 0.03511024, -0.38335645,  0.1827023,   0.53365684,  0.50335765, -0.4760698, 0.36383134, -0.335387, -0.5193737 ],
     [ 0.05425435, -0.24463052, -0.18242478, -0.00777727, -0.03779018, -0.51852536, -0.24997276, -0.3065352, 0.31298703],
     [-0.0291487,   0.18519664, -0.3246611,   0.5765629,  -0.13295686, -0.54634535,  0.46182692, -0.09977704, 0.23855531]])        
    network[4].bias = [[0., 0., 0., 0., 0., 0., 0., 0., 0.]]


    var g = new Graph();
    g.SetElement(myCanvas);
    g.Clear();
    g.AxisX(0,300,10); 
    g.AxisY(1,-.1);
    g.DrawAxis();

    data =[];
    for(var i=0;i<10;i++)
    {
        network[network.length-1].setValue(output);
        
        var res = ForwardPropagation(network, input);
        data.push(res[0])
        
        DumpWeights(network, input);
               
        //BackwardPropagation(network);
        //ApplyDeltas(network, 0.01);
    }
    
    g.DrawArray(data,"#ff0000");
    
    TestNetwork(network, input, output)
}


function Train_Conv2D_LY_1_FM_1_TF()
{
    var input = [
        [0.0,2.0,1.0],
        [0.0,0.0,0.0],
        [0.0,0.0,0.0],
    ];

    var output = [
        [0.0,0.0,0.0],
        [0.0,0.0,0.0],
        [4.0,0.0,0.0],
    ];

    var network = []
    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new QuadraticCostLayer());

    network[1].weights = TransposeMat([[-0.3514839, -0.5428699, -0.1559644], [-0.2815737, 0.3337714, 0.1439681], [-0.51350635, 0.15021497, 0.23279625]])
    network[1].bias = 0.0

    for(var i=0;i<4;i++)
    {
        network[network.length-1].setValue(output);
        ForwardPropagation(network, input);
        DumpWeights(network, input);
        BackwardPropagation(network);
        ApplyDeltas(network, 0.01);
    }
    
    TestNetwork(network, input, output)
}

function Train_Conv2D_LY_2_FM_1_TF()
{
    var input = [
        [1.0,2.0,3.0],
        [4.0,5.0,6.0],
        [7.0,8.0,9.0],
    ];

    var output = [
        [0.0,2.0,0.0],
        [0.0,0.0,0.0],
        [4.0,0.0,0.0],
    ];

    var network = []
    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new QuadraticCostLayer());

    network[1].weights = TransposeMat([[-0.3514839, -0.5428699, -0.1559644], [-0.2815737, 0.3337714, 0.1439681], [-0.51350635, 0.15021497, 0.23279625]])
    network[1].bias = 0.0

    network[2].weights = TransposeMat([[-0.21956453, -0.23107162, 0.51478815], [0.14524263, -0.4497983, -0.33712912], [0.5063044, -0.2550324, -0.3576877]])
    network[2].bias = 0.0


    for(var i=0;i<4;i++)
    {
        network[network.length-1].setValue(output);
        ForwardPropagation(network, input);
        DumpWeights(network, input);
        BackwardPropagation(network);
        ApplyDeltas(network, 0.01);
    }
    
    TestNetwork(network, input, output)
}


function Train_Conv2D_FM_TF()
{
    var input = [
        TransposeMat(
            [
            [1.0,0.0,0.0],
            [0.0,0.0,0.0],
            [0.0,1.0,1.0],
            ]
            )
    ];

    var output = 
    TransposeMat(
    [
        [0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0]
    ]);


    var network = []

    network.push(new InputLayer());
    network.push(new Conv2DFM());
    network.push(new Flatten());
    network.push(new QuadraticCostLayer());
    //w0 = [[[0.01990804 0.41763344], [-0.14347675 -0.1921413 ], [-0.19607109 -0.20445043]], [[-0.39654735  0.38688752], [-0.18929017  0.24505976], [0.2494863  0.31707713]], [[ 0.37121525 -0.06759354], [0.30728313 0.31221274], [0.23029175 0.37514564]]]
    /*
    network[1].weights[0] = ([[0.01990804, -0.14347675, -0.19607109 ], [-0.39654735, -0.18929017, 0.2494863], [0.37121525, 0.30728313, 0.23029175]])
    network[1].bias[0] = 0.0
    network[1].weights[1] = ([[0.41763344, -0.1921413, -0.20445043], [0.38688752, 0.24505976, 0.31707713], [-0.06759354, 0.31221274, 0.37514564]])
    network[1].bias[1] = 0.0
    */
    //network[1].fm = []
    network[1].fm[0] = new Conv2D();
    network[1].fm[0].weights = ([[0.01990804, -0.14347675, -0.19607109 ], [-0.39654735, -0.18929017, 0.2494863], [0.37121525, 0.30728313, 0.23029175]])
    network[1].fm[0].bias = 0.0
    
    network[1].fm[1] = new Conv2D();
    network[1].fm[1].weights = ([[0.41763344, -0.1921413, -0.20445043], [0.38688752, 0.24505976, 0.31707713], [-0.06759354, 0.31221274, 0.37514564]])
    network[1].fm[1].bias = 0.0

    data =[];
    for(var i=0;i<1;i++)
    {
        network[network.length-1].setValue(output);
        
        var res = ForwardPropagation(network, input);
        data.push(res[0])
        
        DumpWeights(network, input);
               
        //BackwardPropagation(network);
        //ApplyDeltas(network, 0.01);
    }
    
    
    TestNetwork(network, input, output)
}


class Road
{    
    constructor(name)
    {
        this.cvs= document.getElementById(name);
        this.ctx = this.cvs.getContext('2d');
        this.Clear();
        
        this.ctx.beginPath();
        this.ctx.strokeStyle="#808080";    
        
        this.line(0,-200,0,200);
        this.line(-200,0,200,0);
        
        this.ctx.closePath();
        this.ctx.stroke(); 
    }

    Clear()
    {
        this.ctx.clearRect(0,0,this.cvs.width,this.cvs.height);
    }
    
    ToX(x) { return x + this.cvs.width*.5; }
    ToY(y) { return - y + this.cvs.height - this.cvs.height*.5; }
    
    line(x1,y1,x2,y2)
    {
        this.ctx.moveTo(this.ToX(x1),this.ToY(y1)); 
        this.ctx.lineTo(this.ToX(x2),this.ToY(y2)); 
    }

    Draw()
    {
        var road = [0,0,45,0,0,90,90,0,-90,-90, 0, 90,90,0,0,90];
    
        var x1 = 0;
        var y1 = 0;
        
        var x2 = 0;
        var y2 = 0;

        var a = 0;
        
        this.ctx.beginPath();
        this.ctx.strokeStyle="#000000";    

        var t = 0;
        var aa = 0;
        
        var n1x = 0;
        var n1y = 5;        
        
        for(var r=0;r<16;r++)
        {
            aa = (3.1415*road[r]/180)/10;
            
            for(var i=0;i<10;i++)
            {                
                var dx = Math.cos(a);
                var dy = Math.sin(a);
                
                var n2x = -5*dy;
                var n2y = 5*dx;
                            
                x2 = x1 + 5 * dx;
                y2 = y1 + 5 * dy;
                
                //this.line(x1,y1,x2,y2);
                        
                this.line(x1+n1x,y1+n1y,x2+n2x,y2+n2y);
                this.line(x1-n1x,y1-n1y,x2-n2x,y2-n2y);

                n1x = n2x;
                n1y = n2y;
                
                x1=x2;
                y1=y2;
                a+=aa;
            }
            
        }
        
        this.ctx.closePath();
        this.ctx.stroke(); 
    }    
}


function init()
{
    var myCanvas = document.getElementById("myCanvas");    
    
    //Train_XOR();
    //Test_Conv1DAndFullyConnected();
    // Test_LearnSin();
    //setInterval(iterate,10);
    //Test_Conv1D()
    //MaxPool1DTest()
    //ConvMaxPoolTest()
    //Test_FullyConnected_1(); //ok
    //Test_FullyConnected_2(); //ok
    //Test_Conv1DPool()
    //Test_Conv1DAndMaxPoolAndFullyConnected2();
    
    //Test_Conv1DDebug4();
    //Test_pack();
    //Train_3dConv();
    //Test_Conv2DDebug1();
    //Test_Conv2DDebug2();
    //Test_Conv2DDebug3();
    //Test_Conv1DDebug()
    //Test_Conv1DDebug4()

    //Train_XOR_TF();
    //Train_Conv2D_TF(); //ok
    //Train_Conv2D_TF_flatten(); //ok
    //Train_Conv2D_LY_1_FM_1_TF(); //ok
    Train_Conv2D_LY_2_FM_1_TF();  //ok
    //Train_Conv2D_FM_2_TF();

    
    //r = new Road("myCanvas");
    //r.Draw();
}
</script>

<body onload="init()">
<h1>Neural network back prop using simple gradient descent, with matrix fomulation + bias for each layer</h1>
<div id="container">
<div id="text" ></div>


<canvas id="myCanvas" width="800" height="300"></canvas>

Let's consider a simple conv network an
d lets compute how to do back propagation on it. </br>



</br>
<h2>Contact/Questions:</h2>
 &lt;my_github_account_username&gt;$@gmail.com$.
</br>
</br>
</div>
</body>
</html>
