<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Neural network back prop, with matrix fomulation</title>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<style type="text/css">
<!--
body { background-color:#ededed; font:norm2al 12px/18px Arial, Helvetica, sans-serif; }
h1 { display:block; width:800px; margin:20px auto; paddVing-bottom:20px; font:norm2al 24px/30px Georgia, "Times New Roman", Times, serif; color:#333; text-shadow: 1px 2px 3px #ccc; border-bottom:1px solid #cbcbcb; }
#container { width:800px; margin:0 auto; }
#myCanvas { background:#fff; border:1px solid #cbcbcb; }
#nav { display:block; width:100%; text-align:center; }
#nav li { display:block; font-weight:bold; line-height:21px; text-shadow:1px 1px 1px #fff; width:100px; height:21px; paddVing:5px; margin:0 10px; background:#e0e0e0; border:1px solid #ccc; -moz-border-radius:4px;-webkit-border-radius:4px; border-radius:4px; float:left; }
#nav li a { color:#000; display:block; text-decoration:none; width:100%; height:100%; }
-->
</style>
</head>
<script>

function RandomMat(inp,neurons)
{
    var L = []
    for(var i=0;i<neurons;i++)
    {
        L[i] = [];7
        for(var j=0;j<inp;j++)
        {
            L[i].push(2*Math.random()-1);
        }
    }
    return L;
}

function PrintMat(m)
{
    var str = "";//"[\n";
    for(var j=0;j<m.length;j++)
    {
    
        var round = [];
        
        for(var i=0;i<m[j].length;i++)
        {
            round.push(m[j][i].toFixed(4))
        }
        str += "[" + round.join(",") + "]\n";
        
        //str += "[" + m[j].join(",") + "]\n";
        
    }
    //str += "]";
    return str;
}

function SquareMat(dimX, dimY)
{
    var O = [];
    for(var i=0;i<dimY;i++)
    {
        O[i] = Array(dimX).fill(0);
    }
    return O;
}

function MatId(dimX, value)
{
    var v = SquareMatId(dimX, dimX, value);
    
    for(var i=0;i<dimY;i++)
    {
        v[i][i]=value;
    }	
}

function MulMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m2[0].length;i++)
        {
            var tmp=0;
            for(var k=0;k<m1[0].length;k++)
            {				
                var v = (m1[j][k] * m2[k][i]);
                
                tmp += v;
            }
            O[j].push( tmp);
        }
    }
    return O;
}

function CheckMat(m, msg)
{
    var l = m[0].length;
    for(var j=0;j<m.length;j++)
    {
        if (l!=m[j].length)
            alert("caca");
            
        for(var i=0;i<m[j].length;i++)
        {
            if (typeof m[j][i] !="number")
            {
                console.log(msg+"\n "+  m[j][i]);		
                debugger;
            }
        }		
    }
}

function TransposeMat(m)
{
    var O = [];
    for(var j=0;j<m[0].length;j++)
    {
        O[j]=[];
        for(var i=0;i<m.length;i++)
        {
            O[j][i] = m[i][j];
        }
    }
    return O;
}

function AddMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] + m2[j][i];
        }
    }
    return O;
}

function SimpleMulMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] * m2[j][i];
        }
    }
    return O;
}

function MulKMat(k, m)
{
    var O = [];
    for(var j=0;j<m.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m[0].length;i++)
        {
            O[j][i] = m[j][i] * k;
        }
    }
    return O;
}

function SubMat(m1, m2)
{
    var O = [];
    for(var j=0;j<m1.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m1[0].length;i++)
        {
            O[j][i] = m1[j][i] - m2[j][i];
        }
    }
    return O;
}

function Square(v)
{
    return MulMat(v, TransposeMat(v))
}

//--------------------------------------------------------

/*
function Act(x)
{
    return x;//1.0/(1.0+Math.exp(-x));
}

function DerAct(x)
{
    return 1;//Act(x)*(1-Act(x));
}
*/


function Act(x)
{
    return 1.0/(1.0+Math.exp(-x));
}

function DerAct(x)
{
    return Act(x)*(1-Act(x));
}

/*
function Act(x)
{
    return Math.max(0,x);
}

function DerAct(x)
{
    return (x>0)?1:0;
}


//softplus 
function Act(x)
{
    return Math.log( 1 + Math.exp(x));
}

function DerAct(x)
{
    return 1.0/(1.0 + Math.exp(-x));
}
*/

//--------------------------------------------------------

function funcMat(func, m )
{
    var O = [];
    for(var j=0;j<m.length;j++)
    {
        O[j]=[];
        for(var i=0;i<m[0].length;i++)
        {
            O[j][i] = func(m[j][i]);
        }
    }
    return O;
}

//--------------------------------------------------------

// this helps taking care of the bias
function AddBiasOneT(vin)
{
    var vout = [].concat(vin);

    vout.push( Array(vout[0].length).fill(1) );
    return vout;
}

//----------------------------------------------------------------

class InputLayer
{
    constructor()
    {
        this.name ="Input";
    }

    forwardPass(input)
    {
        this.o = input
        return this.o;
    }
}

//----------------------------------------------------------------

class OutputLayer
{
    constructor()
    {
        this.name ="Output";
    }

    setValue(v)
    {
        this.value = v;
    }

    forwardPass(input)
    {
        this.diff = SubMat(input, this.value);
                
        var err = 0;
        for(var j=0;j<this.diff.length;j++)
        {	
            for(var i=0;i<this.diff[0].length;i++)
            {
                err += this.diff[j][i] * this.diff[j][i];
            }
        }	

        this.o = [[err]];
        
        return this.o;
    }

    getErrorDer()
    {
        return MulKMat(2,this.diff);
    }

    backpropInput( prev, next)
    {
    }
}

//----------------------------------------------------------------

function ReverseKernel1D(kernel)
{
    return kernel.slice().reverse();
}

function Add1DPaddingMat(input)
{
    var b = input.slice(0);
    b.unshift(Array(input[0].length).fill(0));
    b.push(Array(input[0].length).fill(0));
    return b;
}

function Conv1DInputForward(nonPaddedInput, weights, bias, padding)
{
    var input = Add1DPaddingMat(nonPaddedInput)

    out = []
    for(var y=0;y<input.length-weights.length+ padding;y++)
    {
        var o = bias;
        for(var i=0;i<weights.length;i++)
        {
            o+= input[y+i][0] * weights[i];
        }
        out[y]=[o];
    }
    return out;
}

//----------------------------------------------------------------

class Conv1D
{
    constructor()
    {
        this.weights = [.1,.2,-.3];
        this.bias = .1;
        this.padding = 1;
        this.name ="Conv1D";
    }

    forwardPass(input)
    {
        this.net = Conv1DInputForward(input, this.weights, this.bias, this.padding)
        this.o = funcMat(Act, this.net)
        return this.o;
    }

    getErrorDer()
    {
        var revWeights =  ReverseKernel1D(this.weights);
        return Conv1DInputForward(this.layerDerivative, revWeights, 0, this.padding);
    }

    backpropInput(prev, next)
    {
        var output = next.getErrorDer();

        this.layerDerivative  =  SimpleMulMat(funcMat(DerAct, this.net), output);

        var deltas = []
        for(var i=0;i<this.weights.length+1;i++)
        {
            deltas[i]=[]
        }

        var input = Add1DPaddingMat(prev.o) 

        for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
        {
            for(var j=0;j<this.weights.length;j++)
            {
                deltas[j][y] = input[y+j][0];
            }
            deltas[this.weights.length].push(1);
        }
        
        this.deltas = MulMat(deltas,this.layerDerivative);
    }

    train(LearningRate)
    {
        var weights = this.weights.slice(0);
        weights.push(this.bias);
        weights = [weights];
        var deltas = SubMat( weights, TransposeMat((MulKMat(LearningRate,this.deltas))));
        
        this.weights = deltas[0].slice(0,3);
        this.bias = deltas[0][3];
    }

    AddWeight(i,val)
    {
        if (i<this.weights.length)
            this.weights[i]+=val
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        for(var i=0;i<4;i++)
        {
            this.AddWeight(i,.0001)
            outA.push(ForwardPropagation(network, TransposeMat(input)))
            this.AddWeight(i,-.0001)
            outB.push(ForwardPropagation(network, TransposeMat(input)))
        }
        var out = MulKMat(1.0/.0001,SubMat(outA, outB));
        return out;
    }
}

//----------------------------------------------------------------

function ReverseKernel2D(kernel)
{
    var m = [];
    for(var j=0;j<kernel.length;j++)
        m[j] = kernel[kernel.length-1 - j].slice().reverse();
    return m;
}

function Add2DPaddingMat(input, padding)
{
    var b = [];
    
    for(var i=0;i<input.length;i++)
    {
        var l = input[i].slice(0);
		for(var j=0;j<padding;j++)
			l.unshift(0);
		for(var j=0;j<padding;j++)
			l.push(0);
        b[i] = l;
    }
    
	for(var j=0;j<padding;j++)
		b.unshift(Array(b[0].length).fill(0));
	for(var j=0;j<padding;j++)
		b.push(Array(b[0].length).fill(0));
		
    return b;
}

function Conv2DInputForward(nonPaddedInput, weights, bias, padding)
{
    var input = Add2DPaddingMat(nonPaddedInput, padding)

    out = []

    for(var y=0;y<input.length - weights.length + padding; y++)
    {
        out[y]=[]
        for(var x=0;x<input[0].length - weights.length + padding; x++)
        {		
            var o = bias;
            for(var j=0;j<weights.length;j++)
            {
                for(var i=0;i<weights[0].length;i++)
                {
                    o+= input[y+j][x+i] * weights[i][j];
                }
            }
            out[y].push(o);
        }
    }
    
    return out;
}

//----------------------------------------------------------------

class Conv2D
{
    constructor()
    {
        this.weights = [ [-.1,.2,.3], [.1,.2,-.3], [.1,-.2,.3] ];
        this.bias = .1;
        this.padding = 1;
        this.name ="Conv2D";
    }

    forwardPass(input)
    {
        this.net = Conv2DInputForward(input, this.weights, this.bias, this.padding)
        this.o = funcMat(Act, this.net)
        return this.o;
    }

    getErrorDer()
    {		
        var revKernel = ReverseKernel2D(this.weights)
        return  Conv2DInputForward(this.layerDerivative, revKernel, 0, this.padding)
    }
    
    backpropInput(prev, next)
    {
        var output = next.getErrorDer();

        this.layerDerivative = SimpleMulMat(funcMat(DerAct, this.net), output);

        var ld = [];
        for(var x=0;x<this.layerDerivative.length;x++)
        {
            for(var y=0;y<this.layerDerivative.length;y++)
            {
                ld[x+y*this.layerDerivative.length] = [this.layerDerivative[y][x]];
            }
        }

        var deltas = []
        for(var i=0;i<this.weights.length*this.weights.length+1;i++)
        {
            deltas[i]=[]
        }

        var input = Add2DPaddingMat(prev.o, this.padding)

        for(var x=0;x<input.length-this.weights.length+ this.padding;x++)
        {
            for(var y=0;y<input.length-this.weights.length+ this.padding;y++)
            {
                for(var i=0;i<this.weights.length;i++)
                {
                    for(var j=0;j<this.weights.length;j++)
                    {
                        deltas[j + i * this.weights.length][x + y * prev.o.length] = input[y+j][x+i];
                    }
                }
                deltas[this.weights.length*this.weights.length].push(1);
            }
        }
        
        this.deltas = MulMat(deltas,ld);
    }
        
    AddWeight(i,val)
    {
        if (i<this.weights.length*this.weights.length)
            this.weights[Math.floor(i/3)][i%3]+=val
        else
            this.bias+=val
    }

    numericalDerivarive(network, input)
    {
        var outA = []
        var outB = []
        for(var i=0;i<3*3+1;i++)
        {
            this.AddWeight(i,.0001)
            outA.push(ForwardPropagation(network, TransposeMat(input)))
            this.AddWeight(i,-.0001)
            outB.push(ForwardPropagation(network, TransposeMat(input)))
        }
        var out = MulKMat(1.0/.0001,SubMat(outA, outB));
        
        return out;
    }
}

//----------------------------------------------------------------

class FeatureMap
{
    constructor(featureMap)
    {
        this.name ="Feature Map " + featureMap[0].name;

        this.featureMap = featureMap;
    }

    forwardPass(input)
    {
        this.o = [];
        for(var i=0;i<this.featureMap.length;i++)
        {
            this.o[i] = this.featureMap[i].forwardPass(input[i]);
        }
        return this.o;
    }

    getErrorDer()
    {
        out = [];
        for(var i=0;i<this.featureMap.length;i++)
        {
            out[i] = this.featureMap[i].getErrorDer();
        }
        
        return out;
    }
    
    backpropInput(prev, next)
    {
        for(var i=0;i<this.featureMap.length;i++)
        {
            this.featureMap[i].backpropInput(prev, next);
        }
    }
        
    numericalDerivarive(network, input)
    {
        var out = []
 		for(var i=0;i<this.featureMap.length;i++)
        {
            outA.push(this.featureMap[i].numericalDerivarive(network, input[i]));
        }        
        return out;
    }
}

//----------------------------------------------------------------

class FullyConnected
{
    constructor(neurons, inp)
    {
        this.name ="Fully";
        this.weights = []
        for(var i=0;i<neurons;i++)
        {
            this.weights[i] = [];

            for(var j=0;j<(inp+1);j++)
            {
                this.weights[i].push(2*Math.random()-1);
                //this.weights[i].push(j);
            }
        }
    }

    forwardPass(input)
    {
        this.net = MulMat(this.weights, AddBiasOneT(input))
        this.o = funcMat(Act, this.net)
        return this.o;
    }

    getErrorDer()
    {
        var t = TransposeMat(this.weights)
        t.splice(t.length-1,1);
        return MulMat(t, this.layerDerivative);
    }

    backpropInput(prev, next)
    {
        var output = next.getErrorDer();

        this.layerDerivative  =  SimpleMulMat(funcMat(DerAct, this.net), output);

        this.deltas = MulMat(this.layerDerivative, TransposeMat(AddBiasOneT(prev.o)));
    }

    train(LearningRate)
    {
        this.weights = SubMat( this.weights, MulKMat(LearningRate,this.deltas));
    }

    numericalDerivarive(network, input)
    {
        var out = []
        for(var j=0;j<this.weights.length;j++)
        {
            var vA = []
            var vB = []
            for(var i=0;i<this.weights[0].length;i++)
            {
                this.weights[j][i] += .0001
                vA.push(ForwardPropagation(network, TransposeMat(input)))
                this.weights[j][i] -= .0001
                vB.push(ForwardPropagation(network, TransposeMat(input)))
            }
            var c = MulKMat(1.0/.0001,TransposeMat(SubMat(vA, vB)))[0];

            out.push(c)
        }
        return out;
    }
}

//----------------------------------------------------------------

class MaxPool1D
{
    constructor()
    {
        this.name ="MaxPool 1D";
    }

    forwardPass(input)
    {
        this.o = Array(input.length/2).fill(0)
        this.index = Array(input.length/2).fill(0)
    
        this.errDer = [];
        for(var i=0;i<input.length/2;i++)
        {
            var a = input[i*2][0];
            var b = input[i*2 +1][0];
            this.o[i] = [Math.max(a,b)];
                        
            var row = Array(input.length).fill(0);
            if (a>b)
            {
                row[2*i] = 1;
            }
            else
            {
                row[2*i+1] = 1;
            }
            this.errDer.push(row);
        }
        
        this.input = input;
        return this.o;
    }

    getErrorDer()
    {
        /*
        var out = [];
        for(var i=0;i<this.input.length/2;i++)
        {
            var row = Array(this.input.length).fill(0);
            
            var a = this.input[i*2][0];
            var b = this.input[i*2 +1][0];
            if (a>b)
            {
                row[2*i] = 1;
            }
            else
            {
                row[2*i+1] = 1;
            }
            
            out.push(row);
        }	
        */
        out = this.errDer;
        
        return MulMat(TransposeMat(out), this.layerDerivative);		
    }

    backpropInput(prev, next)
    {
        this.layerDerivative  =  next.getErrorDer();

        this.deltas = [];
        
        return this.layerDerivative;
    }

    train(LearningRate) {};
    
    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MidPool1D
{
    constructor()
    {
        this.name ="MidPool 1D";
    }

    forwardPass(input)
    {
        this.o = Array(input.length/2).fill(0)
    
        for(var i=0;i<input.length/2;i++)
        {
            var a = input[i*2][0];
            var b = input[i*2 +1][0];
            this.o[i] = [(a+b)*0.5];     // average
        }
        
        return this.o;
    }

    getErrorDer()
    {
        var out = [];

        var out = [];
        for(var j=0;j<this.layerDerivative.length;j++)
        {
            var row = [];
            for(var i=0;i<this.layerDerivative[0].length;i++)
            {
                var v = this.layerDerivative[j][i];
                out.push( [v*.5] );
                out.push( [v*.5] );
            }
        }		

        return out;
    }

    backpropInput(prev, next)
    {
        var output = next.getErrorDer();

        this.layerDerivative  =  output;

        this.deltas = [];
        
        return this.layerDerivative;    
    }
    
    train(LearningRate) {};

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MidPool2D
{
    constructor()
    {
        this.name ="MidPool 2D";
    }

    forwardPass(input)
    {
        this.o = []    
        for(var y=0;y<input.length/2;y++)
        {
            var row = [];
            for(var x=0;x<input[0].length/2;x++)
            {
                var a = input[y*2][x*2];
                var b = input[y*2][x*2+1];
                var c = input[y*2+1][x*2];
                var d = input[y*2+1][x*2+1];
                row[x] = (a+b+c+d)*0.25;     // average
            }
            this.o.push(row)
        }        
        return this.o;
    }

    getErrorDer()
    {
        var out = [];

        for(var y=0;y<this.layerDerivative.length;y++)
        {
            var row1 = [];
            var row2 = [];

            for(var x=0;x<this.layerDerivative[0].length;x++)
            {
                var v = this.layerDerivative[y][x];
                
                row1.push(v*.25); row1.push(v*.25);
                row2.push(v*.25); row2.push(v*.25);
            }
            out.push(row1);
            out.push(row2);
        }	
                
        return out;		
    }

    backpropInput(prev, next)
    {
        this.layerDerivative  =  next.getErrorDer();

        this.deltas = [];
        
        return this.layerDerivative;
    }

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class MaxPool2D
{
    constructor()
    {
        this.name ="MaxPool 2D";
    }

    forwardPass(input)
    {        
        this.o = []    
        this.errDer = [];
        for(var y=0;y<input.length/2;y++)
        {
            var row = [];
            var rowErrDer1 = [];
            var rowErrDer2 = [];
            for(var x=0;x<input[0].length/2;x++)
            {
                var a = input[y*2  ][x*2];   var b = input[y*2  ][x*2+1];
                var c = input[y*2+1][x*2];   var d = input[y*2+1][x*2+1];
                
                var res = Math.max(a,Math.max(b,Math.max(c,d)));
                
                row.push(res);
                
                var m = 0;
                if (a==res) m++;
                if (b==res) m++;
                if (c==res) m++;
                if (d==res) m++;
                
                m = 1.0/m;
                                
                rowErrDer1.push( (a==res)?m:0 ); rowErrDer1.push( (b==res)?m:0 );
                rowErrDer2.push( (c==res)?m:0 ); rowErrDer2.push( (d==res)?m:0 );
            }
            
            this.o.push(row);
            
            this.errDer(rowErrDer1);
            this.errDer(rowErrDer2);
        }        
        
        return this.o;
    }

    getErrorDer()
    {               
        return this.errDer;		
    }

    backpropInput(prev, next)
    {
        this.layerDerivative  =  next.getErrorDer();

        this.deltas = [];
        
        return this.layerDerivative;
    }

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

class Flatten
{
    constructor(dimIni)
    {	
        this.dimIni = dimIni;
        this.name ="Flatten";
    }

    forwardPass(input)
    {        
        var row = []

        for(var y=0;y<input.length;y++)
        {
            for(var x=0;x<input[0].length;x++)
            {
                row.push([input[y][x]]);
            }
        }        
        
        this.o = row;
        
        this.width = input[0].length;
        this.height = input.length;
        
        return this.o;
    }

    getErrorDer()
    {               		
        var out = [];
        
        var input = this.layerDerivative;

        for(var y=0;y<this.height;y++)
        {
            var row = [];
            for(var x=0;x<this.width;x++)
            {
                row.push(input[y*this.width + x]);
            }
            out.push(row);
        }        
    
        return out;
    }

    backpropInput(prev, next)
    {
        this.layerDerivative  =  next.getErrorDer();

        this.deltas = [];
        
        return this.layerDerivative;
    }

    numericalDerivarive(network, input)
    {
        return [];
    }
}

//----------------------------------------------------------------

function EvalNetwork(network, input)
{
    var res = input
    for(var i=0;i<network.length-1;i++)
    {
        res = network[i].forwardPass(res);
    }
    return res;
}


function ForwardPropagation(network, input)
{
    var res = input
    for(var i=0;i<network.length;i++)
    {
        res = network[i].forwardPass(res);
    }
    return res;
}

function BackwardPropagation(network)
{
    for(var i=network.length-2;i>0;i--)
    {
      var curr = i
      var prev = network[curr -1];
      var next = (curr + 1)<network.length?network[curr + 1]:undefined;
      network[curr].backpropInput(prev, next);
    }
}

function ApplyDeltas(network, LearningRate)
{
    for(var i=1;i<network.length-1;i++)
    {
        network[i].train(LearningRate);
    }
}

function SimpleTrain(network, input, output, LearningRate, epocsCount, iters)
{
    var t0 = performance.now();
    
    for(var l=0;l<iters;l++)
    {
        for(var epocs=0;epocs<epocsCount;epocs++)
        {
            for(var i=0;i<input.length;i++)
            {
                network[network.length-1].setValue(output[i]);
                
                ForwardPropagation(network, input[i])
                BackwardPropagation(network);
                
                ApplyDeltas(network, LearningRate);
            }
        }
    
        Print(CalcError(network, input, output).toFixed(4) + " : ");
        
        /*
        for(var i=0;i<input.length;i++)
            Print(PrintMat(ForwardPropagation(network, input[i])));
        */
        Print("<br>");
    }
    
    var t1 = performance.now();
    Print("time: " + (t1 - t0) + " milliseconds.<br>");
}

function CalcError(network, input, output)
{
    var totalErr = 0;
    for(var i=0;i<input.length;i++)
    {
        var err = SubMat(ForwardPropagation(network, input[i]), output[i]);
        totalErr += MulMat(err, TransposeMat(err))[0][0];
    }
    return totalErr;
}

function PrepareData(data)
{
    var out = []
    for(var d=0;d<data.length;d++)
    {
        var dd = [];
        for(var i=0;i<data[d].length;i++)
            dd.push([data[d][i]]);
        
        out.push(dd);
    }
    return out;
}

//--------------------------------------------------------------------

function Train_XOR()
{
    Print("Learning a xor:<br><br>");
    var input = PrepareData([[0,0],[1,0],[0,1],[1,1]]);
    var output = PrepareData([[0],[1],[1],[0]]);
    
    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(4,2));
    network.push(new FullyConnected(1,4));
    network.push(new OutputLayer());

    SimpleTrain(network, input, output, .1, 100,10);		
    
    Print("<pre>---------------------------------</pre>");
}

function generate_SIN(size, freq, offset)
{
    var v = Array(size).fill(0)
    for(var t=0;t<size;t++)
    {
        v[t] = Math.sin((2*3.1415)*freq*((t+offset)/(size)));
    }
    return v;
}

function generate_SIN_training(size)
{
    var input = [];
    var output = [];
    
    for(var offset=0;offset<5;offset++)
    {
        for(var f=0;f<size;f++)
        {
            var v = generate_SIN(size, f+1, offset);
            input.push(v);
            output.push((f==0)?[1]:[0]);
        }
        
        {
            var v = Array(size).fill(0)
            for(var i=0;i<size;i++)
            {
                v[i]=i;
            }
            input.push(v);
            output.push([0]);
        }		

        {
            var v = Array(size).fill(0)
            for(var i=0;i<size;i++)
            {
                v[i]=2*Math.random()-1;
            }
            input.push(v);
            output.push([0]);
        }		

        
    }	
    
    return [PrepareData(input), PrepareData(output)];
}

function Train_SIN_fully(trainingSet)
{	
    Print("Learning a sin fully:<br><br>");

    var network =[]
    network.push(new InputLayer());
    network.push(new FullyConnected(5,trainingSet.length));
    network.push(new FullyConnected(1,5));
    network.push(new OutputLayer());
    
    SimpleTrain(network, trainingSet[0], trainingSet[1], .1, 200, 10);		
    
    Print("<pre>---------------------------------</pre>");
    
    return network;
}

function Train_SIN_conv(trainingSet)
{	
    Print("Learning a sin conv:<br><br>");
    
    var network =[]
    network.push(new InputLayer());
    network.push(new Conv1D());    
    network.push(new MidPool1D());
    //network.push(new MaxPool1D());
    network.push(new Conv1D());    
    network.push(new MidPool1D());
    //network.push(new MaxPool1D());
    
    network.push(new FullyConnected(1,4));
    network.push(new OutputLayer());

    SimpleTrain(network, trainingSet[0], trainingSet[1], .1, 200, 10);		
    
    Print("<pre>---------------------------------</pre>");
    
    return network;
}

//----------------------------------------------------------------

function Print(str)
{
    document.getElementById("text").innerHTML += str;
}

function TestNetwork(network, input, output)
{
    network[network.length-1].setValue(TransposeMat(output));

    ForwardPropagation(network, TransposeMat(input))
    for(var i=0;i<network.length;i++)
    {
        Print("<pre>"+i+") Forward pass: "+network[i].name+"</pre>");
        Print("<pre>"+PrintMat(TransposeMat(network[i].o))+"</pre>");
    }

    Print("<pre>---------------------------------</pre>");

    var str = "<table><tr><td>analytical</td><td>numerical</td></tr><tr><td>";

    BackwardPropagation(network);

    for(var i=1;i<network.length-1;i++)
    {
        str += "<pre>"+i+" '" + network[i].name + "'</pre>";
        str += "<pre>"+PrintMat(network[i].deltas)+"</pre>";
    }

    str += "</td><td>";

    //numerical derivative
    for(var i=1;i<network.length-1;i++)
    {
        str += "<pre>"+i+" '" + network[i].name + "'</pre>";
        var c = network[i].numericalDerivarive(network, input);
        str += "<pre>"+PrintMat(c)+"</pre>";
    }

    str += "</tr></table>";

    Print(str);
}

function Test_FullyConnected()
{
    var input = [[1,2,3,4]];

    var network =[]

    network.push(new InputLayer());
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(4,4));
    network.push(new FullyConnected(2,4));
    network.push(new FullyConnected(1,2));
    network.push(new OutputLayer());

    output = [[1]]

    TestNetwork(network, input, output)
}

function Test_Conv1DPool()
{
    var input = [[1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    //network.push(new MidPool1D());
    network.push(new MaxPool1D());
    network.push(new OutputLayer());

    output = [[1]]

    TestNetwork(network, input, output)
}

function Test_Conv1DDebug()
{
    var input = [[1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new Conv1D());    
    network.push(new OutputLayer());

    output = [[1,2]]

    TestNetwork(network, input, output)
}

function Test_Conv1DDebug4()
{
    var input = [[1,2,3,4]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new Conv1D());
    network.push(new Conv1D());
    network.push(new OutputLayer());

    output = [[1,20,3,20]]

    TestNetwork(network, input, output)
}

function Test_Conv1DAndFullyConnected()
{
    var input = [[5,2,1,2]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new FullyConnected(2,2));
    network.push(new FullyConnected(1,2));
    network.push(new OutputLayer());

    output = [[1]];

    TestNetwork(network, input, output)
}

function Test_Conv1DAndMaxPoolAndFullyConnected2()
{
    var input = [[1,2,3,4,5,6,7,8]];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new Conv1D());
    network.push(new MidPool1D());
    network.push(new Conv1D());
    network.push(new FullyConnected(2,2));
    network.push(new OutputLayer());

    output = [[1,2]];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug1()
{
    var input = [
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
        [.01,.02,.03,.04],
    ];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new OutputLayer());

    var output = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
    ];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug2()
{
    var input = [
        [.01,.02,.03,.04],
        [.05,.06,.07,.08],
        [.01,.02,.03,.04],
        [.03,.02,.03,.01],
    ];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new MidPool2D());
    network.push(new Conv2D());
    network.push(new Conv2D());
    network.push(new OutputLayer());

    var output = [
        [0,0],
        [0,0],
    ];

    TestNetwork(network, input, output)
}

function Test_Conv2DDebug3()
{
    var input = [
        [.01,.02,.03,.04],
        [.05,.06,.07,.08],
        [.01,.02,.03,.04],
        [.03,.02,.03,.01],
    ];

    var network =[]

    network.push(new InputLayer());
    network.push(new Conv2D());
    network.push(new Flatten());
    network.push(new FullyConnected(1, 16));

    network.push(new OutputLayer());

    var output = [ [
    1
    ]];

    TestNetwork(network, input, output)
}

function Test_LearnSin()
{
    var trainingSet = generate_SIN_training(16);

    var sin_fully = Train_SIN_fully(trainingSet);
    var sin_conv  = Train_SIN_conv(trainingSet);
    
    var g = new Graph();
    g.SetElement(myCanvas);
    g.Clear();
    g.AxisX(0,160,10); 
    g.AxisY(1,-.1);
    g.DrawAxis();

    output_full = []
    output_conv = []
    for(var n = 0;n<160;n++)
    {
        var data = generate_SIN(16,(n+1)/10.0,Math.random()*0);	
        data = TransposeMat([data]);
                
        output_full.push(EvalNetwork(sin_fully, data))
        output_conv.push(EvalNetwork(sin_conv, data));
    }	
    g.DrawArray(output_full,"#ff0000");
    g.DrawArray(output_conv,"#00ff00");
}

class Road
{    
    constructor(name)
    {
        this.cvs= document.getElementById(name);
        this.ctx = this.cvs.getContext('2d');
        this.Clear();
        
        this.ctx.beginPath();
        this.ctx.strokeStyle="#808080";    
        
        this.line(0,-200,0,200);
        this.line(-200,0,200,0);
        
        this.ctx.closePath();
        this.ctx.stroke(); 
    }

    Clear()
    {
        this.ctx.clearRect(0,0,this.cvs.width,this.cvs.height);
    }
    
    ToX(x) { return x + this.cvs.width*.5; }
    ToY(y) { return - y + this.cvs.height - this.cvs.height*.5; }
    
    line(x1,y1,x2,y2)
    {
        this.ctx.moveTo(this.ToX(x1),this.ToY(y1)); 
        this.ctx.lineTo(this.ToX(x2),this.ToY(y2)); 
    }

    Draw()
    {
        var road = [0,0,45,0,0,90,90,0,-90,-90, 0, 90,90,0,0,90];
    
        var x1 = 0;
        var y1 = 0;
        
        var x2 = 0;
        var y2 = 0;

        var a = 0;
        
        this.ctx.beginPath();
        this.ctx.strokeStyle="#000000";    

        var t = 0;
        var aa = 0;
        
        var n1x = 0;
        var n1y = 5;		
        
        for(var r=0;r<16;r++)
        {
            aa = (3.1415*road[r]/180)/10;
            
            for(var i=0;i<10;i++)
            {				
                var dx = Math.cos(a);
                var dy = Math.sin(a);
                
                var n2x = -5*dy;
                var n2y = 5*dx;
                            
                x2 = x1 + 5 * dx;
                y2 = y1 + 5 * dy;
                
                //this.line(x1,y1,x2,y2);
                        
                this.line(x1+n1x,y1+n1y,x2+n2x,y2+n2y);
                this.line(x1-n1x,y1-n1y,x2-n2x,y2-n2y);

                n1x = n2x;
                n1y = n2y;
                
                x1=x2;
                y1=y2;
                a+=aa;
            }
            
        }
        
        this.ctx.closePath();
        this.ctx.stroke(); 
    }    
}

class Graph
{
    
    SetElement(element)
    {
        this.context = element.getContext('2d');
    }
    
    Clear()
    {
        this.context.clearRect(0,0,600,300);
    }

    map(x1,x2,x)
    {
        return (x-x1)/(x2-x1);
    }

    interpol(a,b,t)
    {
        return (1-t)*a + (t)*b;
    }

    AxisX(x1,x2, step) 
    { 
        this.x1 = x1;
        this.x2 = x2;
        this.stepX = step;
    }

    AxisY(y1,y2) 
    { 
        this.y1 = y1;
        this.y2 = y2;
    }

    ToViewportX(x)
    {
        var t = this.map(this.x1,this.x2,x)
        return this.interpol(0,800,t);
    }

    ToViewportY(y)
    {
        var t = this.map(this.y1,this.y2,y)
        return this.interpol(0,300,t);
    }

    Line(x1,y1,x2,y2)
    {
        x1 = this.ToViewportX(x1);
        y1 = this.ToViewportY(y1);
        x2 = this.ToViewportX(x2);
        y2 = this.ToViewportY(y2);
        this.context.moveTo(x1,y1);
        this.context.lineTo(x2,y2);	
    }
    
    Print(x,y, str)
    {
        x = this.ToViewportX(x);
        y = this.ToViewportY(y);
        this.context.fillText(str,x,y);
    }
    
    DrawAxis()
    {
        this.context.beginPath();
        this.context.strokeStyle="#000000";
        this.Line(this.x1,0,this.x2,0);
        this.Line(0,this.y1,0,this.y2);
        this.context.closePath();
        this.context.stroke();
        
        this.context.beginPath();
        for(var i=0;i<160;i+=this.stepX)
        {
            this.Line(i,0,i,-.025);
            this.Print(i,-.05, i);		
        }
        this.context.closePath();
        this.context.stroke();
        
    }
    
    DrawArray(a, color)
    {
        this.context.beginPath();
        this.context.strokeStyle=color;
        for(var x = 0;x<a.length-1;x++)
        {		
            this.Line(x, a[x], x+1,a[x+1]);
        }
        this.context.closePath();
        this.context.stroke();
    }	
}

function init()
{
    var myCanvas = document.getElementById("myCanvas");    
    
    //Train_XOR();
    //Test_Conv1DAndFullyConnected();
    // Test_LearnSin();

    
    
    //setInterval(iterate,10);
    //Test_Conv1D()
    //MaxPool1DTest()
    //ConvMaxPoolTest()
    //Test_FullyConnected()
    //Test_Conv1DPool()
    //Test_Conv1DAndMaxPoolAndFullyConnected2();
    Test_Conv2DDebug1();
    //Test_Conv2DDebug2();
    //Test_Conv2DDebug3();
    //Test_Conv1DDebug()
    //Test_Conv1DDebug4()
    
    //r = new Road("myCanvas");
    //r.Draw();
}
</script>

<body onload="init()">
<h1>Neural network back prop using simple gradient descent, with matrix fomulation + bias for each layer</h1>
<div id="container">
<div id="text" ></div>


<canvas id="myCanvas" width="800" height="300"></canvas>

Let's consider a simple conv network an
d lets compute how to do back propagation on it. </br>



</br>
<h2>Contact/Questions:</h2>
 &lt;my_github_account_username&gt;$@gmail.com$.
</br>
</br>
</div>
</body>
</html>
